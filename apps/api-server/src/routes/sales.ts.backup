/**
 * Sales Routes - Quotes, Invoices, Delivery Notes
 */

import { errorResponse, isValidUUID, successResponse } from "@crm/utils";
import { invoiceQueries } from "../db/queries";
import { hasCompanyAccess } from "../db/queries/companies-members";
import { userQueries } from "../db/queries/users";
import { logger } from "../lib/logger";
import { verifyAndGetUser } from "../middleware/auth";
import {
	convertOrderToInvoice,
	convertQuoteToInvoice,
	convertQuoteToOrder,
	getDocumentChain,
} from "../services/document-workflow.service";
import { salesService } from "../services/sales.service";
import {
	applyCompanyIdFromHeader,
	getCompanyIdForFilter,
	getStatusFromResponse,
	json,
	parseFilters,
	parsePagination,
	RouteBuilder,
	validateBody,
	withAuth,
} from "./helpers";
import {
	convertToInvoiceSchema,
	convertToOrderSchema,
	createDeliveryNoteSchema,
	createInvoiceSchema,
	createQuoteSchema,
	recordPaymentSchema,
	updateDeliveryNoteSchema,
	updateInvoiceSchema,
	updateQuoteSchema,
} from "./sales-validation";

const router = new RouteBuilder();

// ============================================
// PUBLIC INVOICE ROUTES (no auth required)
// ============================================

// Get invoice by public token (no auth required)
router.get("/api/invoices/token/:token", async (_request, _url, params) => {
	try {
		const invoice = await invoiceQueries.findByToken(params.token);
		if (!invoice) {
			return json(errorResponse("NOT_FOUND", "Invoice not found"), 404);
		}
		return json(successResponse(invoice));
	} catch (error) {
		logger.error({ error }, "Error fetching invoice by token");
		return json(
			errorResponse("DATABASE_ERROR", "Failed to fetch invoice"),
			500,
		);
	}
});

// ============================================
// PUBLIC QUOTE ROUTES (no auth required)
// ============================================

// Get quote by public token (here we use quoteNumber as token)
router.get("/api/quotes/token/:token", async (_request, _url, params) => {
	try {
		const { quoteQueries } = await import("../db/queries/quotes");
		const quote = await quoteQueries.findByNumberWithRelations(params.token);
		if (!quote) {
			return json(errorResponse("NOT_FOUND", "Quote not found"), 404);
		}
		return json(successResponse(quote));
	} catch (error) {
		logger.error({ error }, "Error fetching quote by token");
		return json(errorResponse("DATABASE_ERROR", "Failed to fetch quote"), 500);
	}
});

// Mark quote as viewed (no auth required)
router.post(
	"/api/quotes/token/:token/viewed",
	async (_request, _url, params) => {
		try {
			const { quoteQueries } = await import("../db/queries/quotes");
			const quote = await quoteQueries.findByNumber(params.token);
			if (!quote) {
				return json(errorResponse("NOT_FOUND", "Quote not found"), 404);
			}
			// If quote is draft, mark as sent when viewed (basic parity with invoice)
			if (quote.status === "draft") {
				await quoteQueries.update(quote.id, { status: "sent" });
			}
			return json(successResponse({ success: true }));
		} catch (error) {
			logger.error({ error }, "Error updating quote viewed");
			return json(
				errorResponse("DATABASE_ERROR", "Failed to update quote"),
				500,
			);
		}
	},
);

// Mark invoice as viewed (no auth required)
router.post(
	"/api/invoices/token/:token/viewed",
	async (_request, _url, params) => {
		try {
			const invoice = await invoiceQueries.findByToken(params.token);
			if (!invoice) {
				return json(errorResponse("NOT_FOUND", "Invoice not found"), 404);
			}
			await invoiceQueries.updateViewedAt(invoice.id);
			return json(successResponse({ success: true }));
		} catch (error) {
			logger.error({ error }, "Error updating viewed_at");
			return json(
				errorResponse("DATABASE_ERROR", "Failed to update invoice"),
				500,
			);
		}
	},
);

// ============================================
// QUOTES
// ============================================

router.get("/api/v1/quotes", async (request, url) => {
	return withAuth(request, async (auth) => {
		try {
			const pagination = parsePagination(url);
			const filters = parseFilters(url);

			const effectiveUrl = applyCompanyIdFromHeader(request, url);
			const queryCompanyId = effectiveUrl.searchParams.get("companyId");
			if (queryCompanyId && !isValidUUID(queryCompanyId)) {
				return errorResponse("VALIDATION_ERROR", "Invalid companyId format");
			}

			const { companyId, error } = await getCompanyIdForFilter(
				effectiveUrl,
				auth,
				true,
			);
			if (error) return error;

			return salesService.getQuotes(companyId, pagination, filters);
		} catch (error) {
			logger.error(
				{ error, url: url.toString() },
				"Error in /api/v1/quotes route",
			);
			return errorResponse("INTERNAL_ERROR", "Failed to fetch quotes");
		}
	});
});

router.get("/api/v1/quotes/:id", async (request, _url, params) => {
	return withAuth(request, async () => {
		return salesService.getQuoteById(params.id);
	});
});

router.post("/api/v1/quotes", async (request) => {
	return withAuth(
		request,
		async (auth) => {
			const validation = await validateBody(request, createQuoteSchema);
			if (!validation.success) {
				return validation.error;
			}
			// Transform customerCompanyId to companyId for service compatibility
			const { customerCompanyId, ...rest } = validation.data;
			logger.info({
				auth: { userId: auth.userId, companyId: auth.companyId, role: auth.role },
				customerCompanyId,
				frontendSellerCompanyId: (rest as any).sellerCompanyId
			}, "POST /api/v1/quotes - Auth and payload data");
			return salesService.createQuote({
				...rest,
				companyId: customerCompanyId,
				createdBy: auth.userId,
				sellerCompanyId: auth.companyId,
			});
		},
		201,
	);
});

router.put("/api/v1/quotes/:id", async (request, _url, params) => {
	return withAuth(request, async () => {
		const validation = await validateBody(request, updateQuoteSchema);
		if (!validation.success) {
			return validation.error;
		}
		return salesService.updateQuote(params.id, validation.data);
	});
});

router.patch("/api/v1/quotes/:id", async (request, _url, params) => {
	return withAuth(request, async () => {
		const validation = await validateBody(request, updateQuoteSchema);
		if (!validation.success) {
			return validation.error;
		}
		return salesService.updateQuote(params.id, validation.data);
	});
});

router.delete("/api/v1/quotes/:id", async (request, _url, params) => {
	return withAuth(request, async () => {
		return salesService.deleteQuote(params.id);
	});
});

// ============================================
// INVOICES
// ============================================

router.get("/api/v1/invoices", async (request, url) => {
	return withAuth(request, async (auth) => {
		try {
			const pagination = parsePagination(url);
			const filters = parseFilters(url);

			const effectiveUrl = applyCompanyIdFromHeader(request, url);
			const queryCompanyId = effectiveUrl.searchParams.get("companyId");
			if (queryCompanyId && !isValidUUID(queryCompanyId)) {
				return errorResponse("VALIDATION_ERROR", "Invalid companyId format");
			}

			const { companyId, error } = await getCompanyIdForFilter(
				effectiveUrl,
				auth,
				true,
			);
			if (error) return error;

			return salesService.getInvoices(companyId, pagination, filters);
		} catch (error) {
			logger.error(
				{ error, url: url.toString() },
				"Error in /api/v1/invoices route",
			);
			return errorResponse("INTERNAL_ERROR", "Failed to fetch invoices");
		}
	});
});

router.get("/api/v1/invoices/overdue", async (request, url) => {
	return withAuth(request, async (auth) => {
		// Check if companyId query parameter is provided (for admin to filter by company)
		const effectiveUrl = applyCompanyIdFromHeader(request, url);
		const queryCompanyId = effectiveUrl.searchParams.get("companyId");

		if (queryCompanyId && !isValidUUID(queryCompanyId)) {
			return errorResponse("VALIDATION_ERROR", "Invalid companyId format");
		}

		let companyId: string | null = null;

		if (queryCompanyId) {
			// If companyId is provided in query, verify user has access
			if (auth.role === "tenant_admin" || auth.role === "superadmin") {
				companyId = queryCompanyId;
			} else {
				const hasAccess = await hasCompanyAccess(queryCompanyId, auth.userId);
				if (!hasAccess) {
					return errorResponse("FORBIDDEN", "Not a member of this company");
				}
				companyId = queryCompanyId;
			}
		} else {
			// No query parameter - use user's current active company
			const userCompanyId =
				auth.companyId ?? (await userQueries.getUserCompanyId(auth.userId));

			if (auth.role === "tenant_admin" || auth.role === "superadmin") {
				companyId = userCompanyId;
			} else {
				if (!userCompanyId) {
					return errorResponse("NOT_FOUND", "No active company found for user");
				}
				companyId = userCompanyId;
			}
		}

		return salesService.getOverdueInvoices(companyId);
	});
});

router.get("/api/v1/invoices/:id", async (request, _url, params) => {
	// Try to authenticate, but don't require it
	const auth = await verifyAndGetUser(request);

	const response = await salesService.getInvoiceById(params.id);

	// If successful and not authenticated, sanitize sensitive data
	if (response.success && response.data && !auth) {
		const invoice = { ...response.data };

		// Remove internal/sensitive fields for public view
		if ("internalNote" in invoice) delete (invoice as any).internalNote;
		if ("costPrice" in invoice) delete (invoice as any).costPrice;
		if ("margin" in invoice) delete (invoice as any).margin;

		response.data = invoice;
	}

	return json(response, getStatusFromResponse(response));
});

router.post("/api/v1/invoices", async (request) => {
	return withAuth(
		request,
		async (auth) => {
			const validation = await validateBody(request, createInvoiceSchema);
			if (!validation.success) {
				logger.error({
					validationError: validation.error,
					auth: { userId: auth.userId, companyId: auth.companyId }
				}, "Invoice creation validation failed");
				return validation.error;
			}
			const { customerCompanyId, ...rest } = validation.data;
			logger.info({
				auth: { userId: auth.userId, companyId: auth.companyId },
				customerCompanyId,
				itemsCount: rest.items?.length
			}, "POST /api/v1/invoices - Creating invoice");
			return salesService.createInvoice({
				...rest,
				companyId: customerCompanyId,
				createdBy: auth.userId,
				sellerCompanyId: auth.companyId,
			});
		},
		201,
	);
});

router.put("/api/v1/invoices/:id", async (request, _url, params) => {
	return withAuth(request, async () => {
		const validation = await validateBody(request, updateInvoiceSchema);
		if (!validation.success) {
			return validation.error;
		}
		return salesService.updateInvoice(params.id, validation.data);
	});
});

router.patch("/api/v1/invoices/:id", async (request, _url, params) => {
	return withAuth(request, async () => {
		const validation = await validateBody(request, updateInvoiceSchema);
		if (!validation.success) {
			return validation.error;
		}
		return salesService.updateInvoice(params.id, validation.data);
	});
});

router.delete("/api/v1/invoices/:id", async (request, _url, params) => {
	return withAuth(request, async () => {
		return salesService.deleteInvoice(params.id);
	});
});

router.post("/api/v1/invoices/:id/payment", async (request, _url, params) => {
	return withAuth(request, async () => {
		const validation = await validateBody(request, recordPaymentSchema);
		if (!validation.success) {
			return validation.error;
		}
		return salesService.recordPayment(params.id, validation.data.amount);
	});
});

// ============================================
// DELIVERY NOTES
// ============================================

router.get("/api/v1/delivery-notes", async (request, url) => {
	return withAuth(request, async (auth) => {
		const pagination = parsePagination(url);
		const filters = parseFilters(url);

		const effectiveUrl = applyCompanyIdFromHeader(request, url);
		const queryCompanyId = effectiveUrl.searchParams.get("companyId");
		if (queryCompanyId && !isValidUUID(queryCompanyId)) {
			return errorResponse("VALIDATION_ERROR", "Invalid companyId format");
		}

		const { companyId, error } = await getCompanyIdForFilter(
			effectiveUrl,
			auth,
			false,
		);
		if (error) return error;
		if (!companyId) {
			return errorResponse("VALIDATION_ERROR", "Company ID required");
		}

		return salesService.getDeliveryNotes(companyId, pagination, filters);
	});
});

router.get("/api/v1/delivery-notes/:id", async (request, _url, params) => {
	return withAuth(request, async () => {
		return salesService.getDeliveryNoteById(params.id);
	});
});
router.post("/api/v1/delivery-notes", async (request) => {
	return withAuth(
		request,
		async (auth) => {
			const validation = await validateBody(request, createDeliveryNoteSchema);
			if (!validation.success) {
				return validation.error;
			}
			const { customerCompanyId, ...rest } = validation.data;
			return salesService.createDeliveryNote({
				...rest,
				companyId: customerCompanyId,
				createdBy: auth.userId,
				sellerCompanyId: auth.companyId,
			});
		},
		201,
	);
});

router.put("/api/v1/delivery-notes/:id", async (request, _url, params) => {
	return withAuth(request, async () => {
		const validation = await validateBody(request, updateDeliveryNoteSchema);
		if (!validation.success) {
			return validation.error;
		}
		return salesService.updateDeliveryNote(params.id, validation.data);
	});
});

router.patch("/api/v1/delivery-notes/:id", async (request, _url, params) => {
	return withAuth(request, async () => {
		const validation = await validateBody(request, updateDeliveryNoteSchema);
		if (!validation.success) {
			return validation.error;
		}
		return salesService.updateDeliveryNote(params.id, validation.data);
	});
});

router.delete("/api/v1/delivery-notes/:id", async (request, _url, params) => {
	return withAuth(request, async () => {
		return salesService.deleteDeliveryNote(params.id);
	});
});

router.post(
	"/api/v1/delivery-notes/:id/deliver",
	async (request, _url, params) => {
		return withAuth(request, async () => {
			return salesService.updateDeliveryNoteStatus(params.id, "delivered");
		});
	},
);

// ============================================
// WORKFLOWS (Quote → Order → Invoice)
// ============================================

// Convert Quote to Order
router.post(
	"/api/v1/quotes/:id/convert-to-order",
	async (request, _url, params) => {
		return withAuth(
			request,
			async (auth) => {
				const validation = await validateBody(request, convertToOrderSchema);
				if (!validation.success) {
					return validation.error;
				}

				if (!auth.tenantId) {
					return errorResponse("VALIDATION_ERROR", "Tenant context required");
				}

				const order = await convertQuoteToOrder({
					quoteId: params.id,
					userId: auth.userId,
					tenantId: auth.tenantId,
					customizations: validation.data.customizations
						? {
								orderNumber: validation.data.customizations.orderNumber,
								orderDate: validation.data.customizations.orderDate
									? new Date(validation.data.customizations.orderDate)
									: undefined,
								expectedDeliveryDate: validation.data.customizations
									.expectedDeliveryDate
									? new Date(
											validation.data.customizations.expectedDeliveryDate,
										)
									: undefined,
								notes: validation.data.customizations.notes,
								purchaseOrderNumber:
									validation.data.customizations.purchaseOrderNumber,
							}
						: undefined,
				});

				return successResponse(order);
			},
			201,
		);
	},
);

// Convert Quote directly to Invoice
router.post(
	"/api/v1/quotes/:id/convert-to-invoice",
	async (request, _url, params) => {
		return withAuth(
			request,
			async (auth) => {
				const validation = await validateBody(request, convertToInvoiceSchema);
				if (!validation.success) {
					return validation.error;
				}

				if (!auth.tenantId) {
					return errorResponse("VALIDATION_ERROR", "Tenant context required");
				}

				const invoiceId = await convertQuoteToInvoice({
					quoteId: params.id,
					userId: auth.userId,
					tenantId: auth.tenantId,
					customizations: validation.data.customizations
						? {
								invoiceNumber: validation.data.customizations.invoiceNumber,
								issueDate: validation.data.customizations.issueDate
									? new Date(validation.data.customizations.issueDate)
									: undefined,
								dueDate: validation.data.customizations.dueDate
									? new Date(validation.data.customizations.dueDate)
									: undefined,
								paymentTerms: validation.data.customizations.paymentTerms,
								notes: validation.data.customizations.notes,
							}
						: undefined,
				});

				return successResponse({ invoiceId });
			},
			201,
		);
	},
);

// Convert Order to Invoice
router.post(
	"/api/v1/orders/:id/convert-to-invoice",
	async (request, _url, params) => {
		return withAuth(
			request,
			async (auth) => {
				const validation = await validateBody(request, convertToInvoiceSchema);
				if (!validation.success) {
					return validation.error;
				}

				if (!auth.tenantId) {
					return errorResponse("VALIDATION_ERROR", "Tenant context required");
				}

				const invoiceId = await convertOrderToInvoice({
					orderId: params.id,
					userId: auth.userId,
					tenantId: auth.tenantId,
					customizations: validation.data.customizations
						? {
								invoiceNumber: validation.data.customizations.invoiceNumber,
								issueDate: validation.data.customizations.issueDate
									? new Date(validation.data.customizations.issueDate)
									: undefined,
								dueDate: validation.data.customizations.dueDate
									? new Date(validation.data.customizations.dueDate)
									: undefined,
								paymentTerms: validation.data.customizations.paymentTerms,
								notes: validation.data.customizations.notes,
								partial: validation.data.customizations.partial,
							}
						: undefined,
				});

				return successResponse({ invoiceId });
			},
			201,
		);
	},
);

// Get full document chain for a quote (Quote → Orders → Invoices)
router.get(
	"/api/v1/workflows/document-chain/:quoteId",
	async (request, _url, params) => {
		return withAuth(request, async (auth) => {
			if (!auth.tenantId) {
				return errorResponse("VALIDATION_ERROR", "Tenant context required");
			}

			const chain = await getDocumentChain(params.quoteId, auth.tenantId);
			return successResponse(chain);
		});
	},
);

export const salesRoutes = router.getRoutes();
